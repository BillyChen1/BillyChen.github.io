<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring——IoC容器</title>
    <url>/2020/09/10/spring-ioc/</url>
    <content><![CDATA[<h1 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h1><h2 id="1-思想"><a href="#1-思想" class="headerlink" title="1.思想"></a>1.思想</h2><p><code>bean</code>对象的创建、依赖关系交给<code>Ioc</code>容器来管理，无需手动<code>new</code>对象，方便解耦，便于开发。</p>
<h2 id="2-IoC容器"><a href="#2-IoC容器" class="headerlink" title="2.IoC容器"></a>2.IoC容器</h2><p><code>Spring</code>容器的最顶层接口是<code>BeanFactory</code>，实际开发中常用<code>ApplicationContext</code>。</p>
<p>两个接口的区别：</p>
<ul>
<li><code>ApplicationContext</code>：立即加载。读取配置文件后马上创建对象放入容器。</li>
<li><code>BeanFactory</code>：延迟加载。什么时候根据<code>id</code>获取对象，什么时候才真正创建对象。</li>
</ul>
<p><code>ApplicationContext</code>的三个常用实现类</p>
<ul>
<li><p><code>ClassPathApplicationContext</code>：加载类路径下的配置文件。</p>
</li>
<li><p><code>FileSystemXmlApplicationContext</code>：加载磁盘任意路径下的配置文件。</p>
</li>
<li><p><code>AnnotationConfigApplicationContext</code>：读取注解 创建容器。</p>
</li>
</ul>
<h2 id="3-Bean"><a href="#3-Bean" class="headerlink" title="3.Bean"></a>3.Bean</h2><h3 id="1-创建bean的三种方式"><a href="#1-创建bean的三种方式" class="headerlink" title="1.创建bean的三种方式"></a>1.创建bean的三种方式</h3><ol>
<li>使用默认的无参构造器（如果没有无参构造器，则报错）</li>
<li>使用静态工厂的静态方法创建对象</li>
<li>使用实例工厂的方法创建对象</li>
</ol>
<a id="more"></a>

<h3 id="2-bean对象的生命周期"><a href="#2-bean对象的生命周期" class="headerlink" title="2.bean对象的生命周期"></a>2.bean对象的生命周期</h3><ol>
<li>单例<ul>
<li>出生：当容器创建时对象出生</li>
<li>活着：只要容器还在，对象一直活着</li>
<li>死亡：容器销毁，对象消亡</li>
<li>总结：单例对象的生命周期与容器相同</li>
</ul>
</li>
<li>多例<ul>
<li>出生：使用对象时才创建（延迟加载）</li>
<li>活着：对象只要在使用过程中就一直活着</li>
<li>死亡：当对象长时间不用且无其他对象引用时，由<code>GC</code>回收</li>
</ul>
</li>
</ol>
<h3 id="3-依赖注入"><a href="#3-依赖注入" class="headerlink" title="3.依赖注入"></a>3.依赖注入</h3><p> 依赖关系的管理交给Spring来维护在当前类需要用到其他类的对象时，由Spring为我们提供，只需在配置文件中说明。</p>
<p>依赖注入的数据有三类：</p>
<ol>
<li>基本类型和<code>String</code></li>
<li>其他<code>bean</code>类型（在配置文件中或注解中配置过的bean）</li>
<li>复杂类型（集合类型）</li>
</ol>
<p>注入的方式有三种：</p>
<ol>
<li>使用构造方法</li>
<li>使用<code>set</code>方法</li>
<li>使用注解</li>
</ol>
<h3 id="4-常用注解"><a href="#4-常用注解" class="headerlink" title="4.常用注解"></a>4.常用注解</h3><ol>
<li>用于创建对象的注解（作用类似于<code>bean</code>标签）</li>
</ol>
<ul>
<li><code>@Component</code></li>
</ul>
<blockquote>
<p><strong>作用</strong>：写在类之前，把当前类的对象注入到容器中</p>
<p><strong>属性</strong>：value 指定bean的id 默认值是当前类名首字母改为小写</p>
</blockquote>
<ul>
<li><p><code>@Controller</code>：一般用在表现层</p>
</li>
<li><p><code>@Serive</code>：一般用在业务层</p>
</li>
<li><p><code>@Repository</code>：一般用在持久层</p>
<p>  以上三个注解的作用与属性和<code>Component</code>一样，<br>他们三个是<code>Spring</code>框架提供的明确的三层使用的注解，使三层对象更加清晰。</p>
</li>
</ul>
<ol start="2">
<li>用于注入数据的注解（作用相当于<code>properties</code>标签）</li>
</ol>
<ul>
<li><p><code>@Autowired</code>:</p>
<blockquote>
<p><strong>作用</strong>：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功</p>
<p><strong>使用的位置</strong>：变量上或方法上</p>
<p><strong>注意</strong>：如果容器中没有任何bean的类型匹配，则报错。<br>如果容器中有多个<code>bean</code>的类型和要注入的变量类型匹配，如果要注入的变量名称和<code>bean</code>的<code>id</code>相匹配，则注入之，否则报错。<br>另外，使用注解的方法注入时，set方法不是必须的</p>
</blockquote>
</li>
<li><p><code>@Qualifier</code></p>
<blockquote>
<p><strong>作用</strong>：在按照类中注入的基础上再按名称注入。</p>
<p><strong>注意</strong>：它给类成员注入时不能单独使用，必须和<code>Autowired</code>配合使用，但是在给方法参数注入时可以单独使用。</p>
<p><strong>属性</strong>：<code>value</code> 用于指定注入<code>bean</code>的<code>id</code></p>
</blockquote>
</li>
<li><p><code>@Resource</code></p>
<blockquote>
<p><strong>作用</strong>：直接按照<code>bean</code>的id注入，可以独立使用，不需要再和<code>Autowired</code>一起使用</p>
<p><strong>属性</strong>：name 用于指定注入<code>bean</code>的<code>id</code></p>
<p><strong>注意</strong>：以上三个注解只能注入其他<code>bean</code>类型的数据，而基本类型和<code>String</code>类型无法使用上述注解</p>
</blockquote>
</li>
</ul>
<p>另外，集合类型注入只能使用xml</p>
<ul>
<li><code>@Value</code><blockquote>
<p><strong>作用</strong>：用于注入基本类型和<code>String</code>类型的数据</p>
<p><strong>属性</strong>：<code>value</code>：用于指定数据的值</p>
<p>它可以使用<code>Spring</code>中的<code>SpEL</code>。<code>SpEL</code>写法：<code>${表达式}</code></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习</title>
    <url>/2020/01/30/learngit/</url>
    <content><![CDATA[<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>Git是一个分布式版本控制系统，分为工作区，版本库和远程仓库。</p>
<p>工作区是本地能看到的目录，版本库可分为暂存区和本地仓库，远程仓库被置于远程，可由Github托管。</p>
<p>把本地文件放入本地仓库分两步进行：</p>
<p>第一步：<code>git add</code>将工作区的文件添加到暂存区；</p>
<p>第二步：<code>git commit</code>将暂存区的所有内容提交到本地仓库（当前分支）</p>
<p>接下来，在本地仓库和远程仓库已经关联的条件下，即可使用<code>git push</code>推送当前分支到远程。</p>
<a id="more"></a>

<hr>
<h2 id="多人协作开发"><a href="#多人协作开发" class="headerlink" title="多人协作开发"></a>多人协作开发</h2><p><code>master</code>分支是主分支，用于发布版本；</p>
<p><code>dev</code>分支是开发分支。每个成员都在各自<code>dev</code>分支上开发，并时不时地推送到远程；</p>
<p><code>feature</code>分支可用于开发新功能，开发完成后，合并到<code>dev</code>分支，最后删除<code>dev</code>分支；</p>
<p><code>bug</code>分支可以被临时建立来修改bug，修改后，合并分支，删除<code>bug</code>分支。</p>
<p>总之，<code>master</code>分支用于发布版本，每个人在各自的<code>dev</code>分支上开发，时不时往远程的<code>dev</code>进行提交，合并。如果向远程提交<code>dev</code>分支时出现冲突（即你的同伴和你对同一份文件进行了修改），则需要先<code>git pull</code>，在本地解决冲突后再提交(<code>git commit</code>、<code>git push</code>)</p>
<hr>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li><p>将指定文件添加进入暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>（<code>git add .</code>表示将所有文件加入暂存区）</p>
</li>
<li><p>删除版本库中暂存区指定文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm &lt;filename&gt;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>将暂存区的修改提交到本地仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"your change"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>本地仓库与远程仓库建立联系（确保SSH Key已经配置好）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/YOUR_NAME/REPO_NAME.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>将远程分支拉到工作区（出现冲突时需要进行这一步，因为要在本地进行合并）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交到远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>如果远程仓库为空，则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin &lt;branch&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从远程仓库克隆（会自动把本地仓库与远程仓库关联起来）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/YOUR_NAME/REPO_NAME.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并进入分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch -c &lt;branch&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch &lt;branch&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将目标分支合并到当前分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branch&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看分支情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline --graph</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看以往提交的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
</li>
<li><p>版本回退<br>回退指定次数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD~&lt;<span class="built_in">times</span>&gt;</span><br></pre></td></tr></table></figure>
<p>回退指定commit_id的版本（id可在log或reflog中找到）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard &lt;commit_id&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>改乱了工作区内的内容，想丢弃工作区的修改（返回到版本库的状态）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>改乱了工作区的内容并且提交到暂存区，以下命令可将修改回退到工作区，此时就回到了上一个场景的情况</p>
<pre><code class="bash">git reset HEAD &lt;filename&gt;</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10 + Ubuntu 16.04 双系统安装步骤以及问题的解决</title>
    <url>/2020/01/19/windows-ubuntu/</url>
    <content><![CDATA[<h1 id="Win10-Ubuntu-16-04-双系统安装步骤以及问题的解决"><a href="#Win10-Ubuntu-16-04-双系统安装步骤以及问题的解决" class="headerlink" title="Win10 + Ubuntu 16.04 双系统安装步骤以及问题的解决"></a>Win10 + Ubuntu 16.04 双系统安装步骤以及问题的解决</h1><h2 id="双系统安装步骤"><a href="#双系统安装步骤" class="headerlink" title="双系统安装步骤"></a>双系统安装步骤</h2><h3 id="步骤一：Ubuntu-16-04系统盘的制作"><a href="#步骤一：Ubuntu-16-04系统盘的制作" class="headerlink" title="步骤一：Ubuntu 16.04系统盘的制作"></a>步骤一：Ubuntu 16.04系统盘的制作</h3><ol>
<li>下载Ubuntu镜像<br> 推荐使用<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/16.04/" target="_blank" rel="noopener">清华大学开源软件镜像站</a>,选择ubuntu-16.04.6-desktop-amd64.iso下载即可</li>
<li>下载UltraSO，使用U盘制作启动盘<ol>
<li>选择<em>文件-&gt;打开</em>，打开Ubuntu的iso镜像。</li>
<li>在左下角区域选择U盘，点击<em>启动-&gt;写入硬盘映像</em>。</li>
<li>在弹出的对话框中选择写入方式为hdd或hdd+，对硬盘格式化后再点击写入。</li>
<li>写入完毕后启动盘制作完成。</li>
</ol>
</li>
</ol>
<h3 id="步骤二：分区与安装"><a href="#步骤二：分区与安装" class="headerlink" title="步骤二：分区与安装"></a>步骤二：分区与安装</h3><ol>
<li>使用Windows磁盘管理进行分区。<br> 通过<em>WIN + X</em>进入磁盘管理，右键点击有空余空间的磁盘，选择<em>压缩卷</em>，一般大小可设置为50G。此后的Ubuntu系统便安装在此区域。</li>
<li>关闭Win10系统的快速启动和安全启动。<br> 具体操作可参考<a href="https://www.jianshu.com/p/38e6be8efecf" target="_blank" rel="noopener">win10安装ubuntu18.04 LTS双系统</a></li>
<li>将启动盘插入电脑，重启电脑，进入BIOS，将U盘设置为第一启动项。</li>
<li>按照提示信息进行安装。<ul>
<li><strong>注意</strong>：在分区时，选择自定义模式。一般来说，只需要划分两个区，即swap区(充当虚拟内存，分区格式为swap)和主分区(挂载点/，安装系统和软件，分区格式为ext4)</li>
</ul>
</li>
<li>安装完成后，拔下U盘，重启电脑，选择进入Ubuntu系统。至此，双系统安装已经完成。</li>
</ol>
<a id="more"></a>
<hr>
<h2 id="遇到的问题以及解决方案"><a href="#遇到的问题以及解决方案" class="headerlink" title="遇到的问题以及解决方案"></a>遇到的问题以及解决方案</h2><h3 id="双系统安装在logo界面卡死"><a href="#双系统安装在logo界面卡死" class="headerlink" title="双系统安装在logo界面卡死"></a>双系统安装在logo界面卡死</h3><p><strong>解决方案：</strong> 问题的原因可能是Ubuntu系统对双显卡支持不友好，可以在安装过程中选中install ubuntu选项，按e键进入编辑</p>
<p>将<code>quite splash ---</code>改为<code>quite splash nomodeset</code></p>
<p>显卡被禁止后默认分辨率为800x600，所以窗口可能显示不全，此时只需要按住<em>alt + s</em>（或者<em>alt + F7</em>）拖动窗口即可。</p>
<p>重启电脑后，进入Ubuntu系统仍需要进行上述修改。</p>
<p>进入Ubuntu系统后，如果无线网络连接正常（如果无法连接无线网，则需要接网线使用有线网），可以在<em>系统设置-&gt;软件和更新-&gt;附加驱动</em>中找到NVDIA相关选项，选择<em>应用更改</em>后重新启动即可解决显卡问题。</p>
<h3 id="无线网卡问题"><a href="#无线网卡问题" class="headerlink" title="无线网卡问题"></a>无线网卡问题</h3><p>   进入Ubuntu系统后，可能无法找到无线网络。原因可能是系统对硬件支持不友好，无法直接找到无线网卡驱动。</p>
<p>   <strong>解决方案：</strong> 网络上最常用的解决方法是在终端输入以下命令（当然需要确保有线网络已连接）：</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install bcmwl-kernal-source</span><br></pre></td></tr></table></figure>

<p>   如果问题仍然无法解决，那么就需要手动下载对应你的无线网卡型号的驱动软件。</p>
<p>   以我为例，我的网卡型号为rtl8821ce。</p>
<ol>
<li><p>下载网卡驱动。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/endlessm/linux/tree/master/drivers/net/wireless/rtl8821ce</span><br></pre></td></tr></table></figure></li>
<li><p>修改Makefile文件<br>  将<code>export TopDIR ?=</code>之后的内容改为当前目录地址，例如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export TopDIR ?&#x3D; &#x2F;home&#x2F;chenqiming&#x2F;rtl8821ce&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在当前目录下打开终端，进行：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br><span class="line">$ sudo modprobe -a 8821ce</span><br></pre></td></tr></table></figure>
<p>至此，驱动已经安装完成，重新启动后即可寻找到无线wifi。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
